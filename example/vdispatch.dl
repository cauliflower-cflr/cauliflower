/*
 * This file records how we generate input CSV files from datalog facts
 * I'm prepared to believe what we are doing is not accurate, (we definitely
 * do not capture full java semantics, and i wouldnt be surprised if we got
 * some of the relations backwards)  However, this still generates a
 * representative problem, which we canalyse
 */


/* +-------+
   | TYPES |
   +-------+ */

.type Type
.type Var
.type HeapAllocation
.type Field
.type Int

.type MethodSignature
.type Callsite
.type MethodName
.type MethodDescriptor

.type Cruft // i use this whenever i have a relation that i dont care about

/* +--------------+
   | DECLARATIONS |
   +--------------+ */

.decl DirectSuperclass(sub:Type, super:Type)  input
.decl DirectSuperinterface(sub:Type, super:Type)  input

.decl ClassType(cla:Type) input

.decl Method(sig:MethodSignature, name:MethodName, desc:MethodDescriptor, owner:Type, return:Cruft, short_desc:Cruft) input
.decl FormalParam(index:Int, sig:MethodSignature, param:Var) input
.decl ActualParam(index:Int, callsite:Callsite, param:Var) input
.decl Return(instruction:Cruft, instruction_num:Int, ret:Var, sig:MethodSignature)
.decl VirtualMethodInvocation(ref:Callsite, index:Int, called_method:MethodSignature, reciever:Var, caller:MethodSignature) input
.decl SpecialMethodInvocation(ref:Callsite, index:Int, called_method:MethodSignature, reciever:Var, caller:MethodSignature) input
.decl StaticMethodInvocation(ref:Callsite, index:Int, called_method:MethodSignature, caller:MethodSignature) input

// assignments
.decl AssignCast(instruction:Cruft, instruction_num:Int, from:Var, to:Var, ty:Type, context:MethodSignature) input
.decl AssignLocal(instruction:Cruft, instruction_num:Int, variableAssigned:Var, variableAssignedTo:Var, containingMethod:MethodSignature)  input

.decl AssignHeapAllocation(instruction:Cruft, instruction_num:Int, heapAllocation:HeapAllocation, variableAssignedTo:Var, containingMethod:MethodSignature)  input
.decl NormalHeap(alloc:HeapAllocation, ty:Type) input

// load and store
.decl LoadInstanceField(instruction:Cruft, instruction_num:Int, instanceVariable:Var, field:Field, variableAssignedTo:Var, containingMethod:MethodSignature)  input
.decl StoreInstanceField(instruction:Cruft, instruction_num:Int, storedVariable:Var, instanceVariable:Var, field:Field, containingMethod:MethodSignature)  input

/* +-------+
   | RULES |
   +-------+ */

// Relate method signatures to their descriptors
.decl MethodSignatureDescriptor(sig:MethodSignature, desc:MethodDescriptor)
MethodSignatureDescriptor(sig, desc) :- Method(sig, _, desc, _, _, _).

// Relate method signatures to their names
.decl MethodSignatureSimpleName(sig:MethodSignature, nam:MethodName)
MethodSignatureSimpleName(sig, nam) :- Method(sig, nam, _, _, _, _).

// Relate method signatures to their owning types
.decl MethodSignatureType(sig:MethodSignature, ty:Type)
MethodSignatureType(sig, ty) :- Method(sig, _, _, ty, _, _).

// The immediate superclass is a superclass.
// All intermediate superclasses are superclasses.
.decl Superclass(sub:Type, super:Type)
Superclass(sub,super) :- DirectSuperclass(sub,super).
Superclass(sub,super) :- Superclass(sub,x), DirectSuperclass(x, super).

// A type is compatible to itself.
// A sub/super class relationship makes types compatible.
// An interface relationship makes types compatible.
.decl IsTypeCompatible(sub:Type, super:Type)
IsTypeCompatible(sub, sub) :- IsTypeCompatible(sub, _).
IsTypeCompatible(sub, sub) :- IsTypeCompatible(_, sub).
IsTypeCompatible(sub, super) :- Superclass(sub,super).
IsTypeCompatible(sub, super) :- DirectSuperinterface(sub, super).

// Relation between two methods showing which method overwrites another one 
// in the class hierarchy.  Two methods overwrite, if they have the same name
// and the same type signature and the class of method subM is a 
// sub-type of the class/interface of method superM. 
// Note that method subM resides in a class whereas superM can either reside
// in a class or is defined in an interface. 
.decl OverwritesMethod(subM:MethodSignature, superM:MethodSignature)
OverwritesMethod(subM, superM) :-
    MethodSignatureDescriptor(subM, descriptor),
    MethodSignatureDescriptor(superM, descriptor),
    MethodSignatureSimpleName(subM, simpleName), 
    MethodSignatureSimpleName(superM, simpleName),
    MethodSignatureType(subM, subClass), 
    ClassType(subClass), 
    MethodSignatureType(superM, superType), 
    IsTypeCompatible(subClass, superType).

// Check whether the class in which the virtual method resides, has a strict sub-class 
// that overlaps the method the sub-class is a super-class of type. 
.decl HasSubClassWithMethod(superM:MethodSignature, type:Type) 
HasSubClassWithMethod(superM, type) :- 
    OverwritesMethod(subM, superM),
    subM != superM, 
    MethodSignatureType(superM, superClass),
    MethodSignatureType(subM, subClass), 
    IsTypeCompatible(type, subClass).

// Dispatch a virtual call to the method call that matches the type of the 
// heap object
// To resolve a virtual dispatch call, the closest overlapping 
// method to the type of the heap object is searched. 
.decl VirtualCall(superM:MethodSignature, hobjType:Type, invokedMethod:MethodSignature) printsize
VirtualCall(superM, hobjType, invokedMethod) :- 
    OverwritesMethod(invokedMethod, superM), 
    MethodSignatureType(invokedMethod, containingClass),
    MethodSignatureType(superM, superClass), 
    IsTypeCompatible(hobjType, containingClass), 
    !HasSubClassWithMethod(invokedMethod, hobjType).

/* +------+
   | CSVs |
   +------+ */

.decl RAssign(varAssigned:Var, varAssignedTo:Var) 
RAssign(localVarAssigned, localVarAssignedTo) :- 
  AssignLocal(_, _, localVarAssigned, localVarAssignedTo, _).
RAssign(var2, var1) :-         
  AssignCast(_, _, var2, var1, _, _).
RAssign(actual, formal) :-
  StaticMethodInvocation(site, _, method, _),
  FormalParam(index, method, formal),
  ActualParam(index, site, actual).

.decl Assign(x:Var, y:Var) printsize
Assign(x,y) :- 
  RAssign(y,x).

.decl Alloc(x:Var, o:HeapAllocation) printsize
Alloc(var, heap)  :- 
  AssignHeapAllocation(_, _, heap, var, _).

.decl AllocType(t:Type, o:HeapAllocation) printsize
AllocType(t, o) :-
  AssignHeapAllocation(_, _, o, _, _), NormalHeap(o, t).

.decl Store(src:Var, base:Var, field:Field) printsize
Store(s, b, f) :- StoreInstanceField(_, _, s, b, f, _).
.decl Load(base:Var, dst:Var, field:Field) printsize
Load(b, d, f) :- LoadInstanceField(_, _, b, f, d, _).

